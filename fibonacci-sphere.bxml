<x:document xmlns:x="http://local/" width="flex"
            title="Fibonacci Sphere for planet generation">

  <x:published>19 Oct 2018</x:published>
  
  <style>
      body.widthflex section > figure { width: unset; max-width: unset; }
      canvas { max-width: 90vmin; }
  </style>
  
  <x:section>

    <p>
      The first step for a Voronoi Planet is to pick the points. I would like evenly spaced points to start with. The standard approach is to use a subdivided icosahedron. I'm going to try using a Fibonacci Sphere instead. I don't know if it will work well but I've wanted to try it, and procjam was the perfect excuse. The algorithm is adapted from <a href="http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere">this page</a>, which was linked <a href="http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere">from stackoverflow</a>. Also see <a href="https://beta.observablehq.com/@mbostock/spherical-fibonacci-lattice">Mike Bostock's version</a>, based on <a href="http://extremelearning.com.au/evenly-distributing-points-on-a-sphere/">this reference page</a>, which proposes an improvement over the Fibonacci approach. I had that page bookmarked but had forgotten to check it before writing this page. :(
    </p>
    
    <p>
      <button onclick="setAlgorithm(1)">Algorithm 1</button>
      <button onclick="setAlgorithm(2)">Algorithm 2</button>
      <br/>
      Number of points on sphere:
      <input type="range" min="1" max="5" step="0.001" value="4" oninput="setN(Math.pow(10, this.valueAsNumber) | 0)" style="width:50ex"/>
      <br/>
      Jitter: <input type="range" min="0" max="1" step="0.001" value="0" oninput="setJitter(this.valueAsNumber)" style="width:50ex"/>
      <br/>
      Sphere rotation: <input type="range" min="-5" max="5" step="0.001" value="0" oninput="setRotation(this.valueAsNumber)" style="width:50ex"/>
    </p>
    
    <figure>
      <canvas id="output" width="1024" height="1024"/>
    </figure>

    <p>
      Want code?  Use View Source in your browser. It's all on this page. See the generateFibonacciSphere{1,2} functions. Graphics are rendered with <a href="http://regl.party">regl.js</a>, which makes it much easier for me to use WebGL than if I had tried using WebGL directly. I also use a little bit of <a href="http://glmatrix.net/">glMatrix</a>.
    </p>
    
  </x:section>

  <x:footer>
    <script src="/js/regl.js"/>
    <script src="https://unpkg.com/gl-matrix@2.7.0/dist/gl-matrix.js"/>
    <script>
'use strict';

const regl = createREGL({
    canvas: "#output",
    extensions: ['OES_element_index_uint']
});

const render = regl({
    frag: `
precision mediump float;
varying vec2 v_uv;
void main() {
   gl_FragColor = vec4(1.0 - v_uv.r, 0.5 - 0.5 * v_uv.r, v_uv.r, 1);
}
`,

    vert: `
#define M_PI 3.1415926535897932384626433832795
precision highp float;
uniform mat4 u_projection;
uniform float u_pointsize;
attribute vec2 a_latlong;
varying vec2 v_uv;
void main() {
  v_uv = vec2(a_latlong.r / 180.0 + 0.5, fract((a_latlong.g + 90.0) / 360.0));
  float lat = a_latlong.r / 180.0 * M_PI;
  float lon = a_latlong.g / 180.0 * M_PI;
  gl_Position = u_projection * 
                 vec4(cos(lat) * cos(lon),
                      cos(lat) * sin(lon),
                      sin(lat),
                      1);
  gl_PointSize = gl_Position.z > 0.0? 1.0 : u_pointsize;
}
`,

    uniforms: {
        u_projection: regl.prop('u_projection'),
        u_pointsize: regl.prop('u_pointsize'),
    },

    primitive: 'points',
    count: regl.prop('count'),
    attributes: {
        a_latlong: regl.prop('a_latlong'),
    },
});

let randomLat = [], randomLon = [];
function generateFibonacciSphere1(N, jitter) {
    let a_latlong = [];

    // First algorithm from http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere
    const s = 3.6/Math.sqrt(N);
    const dz = 2.0/N;
    for (let k = 0, long = 0, z = 1 - dz/2; k !== N; k++, z -= dz) {
        let r = Math.sqrt(1-z*z);
        let latDeg = Math.asin(z) * 180 / Math.PI;
        let lonDeg = long * 180 / Math.PI;
        if (randomLat[k] === undefined) randomLat[k] = Math.random() - Math.random();
        if (randomLon[k] === undefined) randomLon[k] = Math.random() - Math.random();
        latDeg += jitter * randomLat[k] * (latDeg - Math.asin(Math.max(-1, z - dz * 2 * Math.PI * r / s)) * 180 / Math.PI);
        lonDeg += jitter * randomLon[k] * (s/r * 180 / Math.PI);
        a_latlong.push(latDeg, lonDeg);
        long += s/r;
    }
    return a_latlong;
}


function generateFibonacciSphere2(N, jitter) {
    let a_latlong = [];

    // Second algorithm from http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere
    const s = 3.6/Math.sqrt(N);
    const dlong = Math.PI * (3-Math.sqrt(5));  /* ~2.39996323 */
    const dz = 2.0 / N;
    for (let k = 0, long = 0, z = 1 - dz/2; k !== N; k++, z -= dz) {
        let r = Math.sqrt(1 - z*z);
        let latDeg = Math.asin(z) * 180 / Math.PI;
        let lonDeg = long * 180 / Math.PI;
        if (randomLat[k] === undefined) randomLat[k] = Math.random() - Math.random();
        if (randomLon[k] === undefined) randomLon[k] = Math.random() - Math.random();
        latDeg += jitter * randomLat[k] * (latDeg - Math.asin(Math.max(-1, z - dz * 2 * Math.PI * r / s)) * 180 / Math.PI);
        lonDeg += jitter * randomLon[k] * (s/r * 180 / Math.PI);
        a_latlong.push(latDeg, lonDeg);
        long += dlong;
    }
    return a_latlong;
}

function generateFibonacciSphere(N, jitter) {
    return [null, generateFibonacciSphere1, generateFibonacciSphere2][algorithm](N, jitter);
}
      
let N = 10000;
let jitter = 0.0;
let rotation = 0.8;
let algorithm = 1;
      
function draw() {
    let u_projection = mat4.fromRotation([], rotation, [1, 0.5, 0]);
    let u_pointsize = 0.5 + 500 / Math.sqrt(N);
    let a_latlong = generateFibonacciSphere(N, jitter);
    render({
        u_projection,
        u_pointsize,
        a_latlong,
        count: a_latlong.length / 2,
    });
}

function setAlgorithm(newAlgorithm) { algorithm = newAlgorithm; draw(); }
function setN(newN) { N = newN; draw(); }
function setJitter(newJitter) { jitter = newJitter; draw(); }
function setRotation(newRotation) { rotation = newRotation; draw(); }
draw();
    </script>
    
    Created 19 Oct 2018; &#160;
    <!-- hhmts start -->Last modified: 20 Oct 2018<!-- hhmts end -->
  </x:footer>
  
  
</x:document>

